at-random
	Similar to at, cron, and sleep, but with
	a random amount of time. It should be
	possible to select random distribution
	and parameters. For example normal
	(Gaussian) distribution with a specified
	expectation and a specified standard
	deviation.

pnf
	Plain-text News Feed, like RSS and Atom,
	but in plain-text. So that it is easy to
	write, easy to read, and easy to parse.

kmn
	Kill Me Now, logout everywhere. This is
	useful on a public machine. You may forget
	that you are also login on a TTY, (this
	happens,) and you would not want someone
	to find your TTY session (this happens
	too.)

(kpasswd + libpassphrase)
	kpasswd needs to be patched to use
	libpassphrase.
	Of course, everything should use
	libpassphrase, but kpasswd is extra
	important.

mktree
	find | mktree # = tree
	tree | mktree --untree # = find
	It should be possible to select indent
	and another delimiter than /.

unod
	Convert output from od (and similar
	data) to raw form.

vttrans
	A pts(4)-based and a pipe-based filter for
	translating unsupported (by the TTY) symbols
	to supported symbols. Too few, even important,
	programs restrict themself.

bus-dbus
	It is possible to make programs using dbus to
	instead use bus, without modifying those programs?

libescape
	Parse ANSI escape codes.
	Generate ANSI escape codes, primarily
	set of macros to make strings mroe readble
	for those not too familiar with escape codes.

chave
	For use i C code, in combination with gpp or
	similar.
	In one mode:
	  For everything #include lines from stdin that
	  does not use macros and uses < >. Determine
	  if the file exists. If it does not exist,
	  clear the line. At the end of it all, without
	  causing havoc on the line numbers, define
	  HAVE_H_* for all found header files.
	In another mode:
	  Pipe through cpp, print the output, but then
	  also, without causing havoc on the line numbers,
	  define HAVE_FUN_* and HAVE_VAR_* for all
	  function and variables.

uvg
	Unscalable Vector Graphics, an alternativ to
	SVG that simple enought that images can be
	written by hand. And does not use XML, but
	a LISP-like syntax instead

numgroup
	$ numgroup --offset 1 --size 10 << EOF
	1
	0.5
	1.5
	10
	25
	20
	EOF
	 1 - 11
	-9 -  1
	 1 - 11
	 1 - 11
	21 - 31
	11 - 21

karnaugh (since some distro's package manager is already called dnf)
	karnaugh dnf
		convert an expression to DNF
	karnaugh dnf --map
		convert a ternary map to DNF
	karnaugh cnf
		convert an expression to CNF
	karnaugh cnf --map
		convert a ternary map to CNF
	Accept both x and Î¦ for in maps.

